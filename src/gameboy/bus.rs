use super::{
    cartridge::{self, Cartridge},
    ppu::Ppu,
};

pub struct Bus {
    pub cartridge: Box<dyn Cartridge>,
    pub ppu: Ppu,
    pub working_ram: [u8; 0x2000],
    pub io: [u8; 0x100],
    pub zero_page: [u8; 0x80],

    pub bios_enabled: bool,
    pub bios: [u8; 0x100],
}

impl Bus {
    pub fn new(cartridge: Box<dyn Cartridge>) -> Self {
        Self {
            cartridge,
            ppu: Ppu::new(),
            working_ram: [0; 0x2000],
            io: [0; 0x100],
            zero_page: [0; 0x80],

            bios_enabled: true,
            bios: [
                0x31, 0xFE, 0xFF, 0x21, 0xFF, 0x9F, 0xAF, 0x32, 0xCB, 0x7C, 0x20, 0xFA, 0x0E, 0x11,
                0x21, 0x26, 0xFF, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0x32, 0xE2, 0x0C, 0x3E,
                0x77, 0x32, 0xE2, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0xB8, 0x00, 0x1A,
                0xCB, 0x37, 0xCD, 0xB8, 0x00, 0x13, 0x7B, 0xFE, 0x34, 0x20, 0xF0, 0x11, 0xCC, 0x00,
                0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9, 0x21, 0x04, 0x99, 0x01, 0x0C,
                0x01, 0xCD, 0xB1, 0x00, 0x3E, 0x19, 0x77, 0x21, 0x24, 0x99, 0x0E, 0x0C, 0xCD, 0xB1,
                0x00, 0x3E, 0x91, 0xE0, 0x40, 0x06, 0x10, 0x11, 0xD4, 0x00, 0x78, 0xE0, 0x43, 0x05,
                0x7B, 0xFE, 0xD8, 0x28, 0x04, 0x1A, 0xE0, 0x47, 0x13, 0x0E, 0x1C, 0xCD, 0xA7, 0x00,
                0xAF, 0x90, 0xE0, 0x43, 0x05, 0x0E, 0x1C, 0xCD, 0xA7, 0x00, 0xAF, 0xB0, 0x20, 0xE0,
                0xE0, 0x43, 0x3E, 0x83, 0xCD, 0x9F, 0x00, 0x0E, 0x27, 0xCD, 0xA7, 0x00, 0x3E, 0xC1,
                0xCD, 0x9F, 0x00, 0x11, 0x8A, 0x01, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x1B, 0x7A,
                0xB3, 0x20, 0xF5, 0x18, 0x49, 0x0E, 0x13, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xC9, 0xF0,
                0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0xC9, 0x78, 0x22, 0x04, 0x0D, 0x20,
                0xFA, 0xC9, 0x47, 0x0E, 0x04, 0xAF, 0xC5, 0xCB, 0x10, 0x17, 0xC1, 0xCB, 0x10, 0x17,
                0x0D, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5,
                0x42, 0x3C, 0x00, 0x54, 0xA8, 0xFC, 0x42, 0x4F, 0x4F, 0x54, 0x49, 0x58, 0x2E, 0x44,
                0x4D, 0x47, 0x20, 0x76, 0x31, 0x2E, 0x32, 0x00, 0x3E, 0xFF, 0xC6, 0x01, 0x0B, 0x1E,
                0xD8, 0x21, 0x4D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x3E, 0x01, 0xE0, 0x50,
            ],
        }
    }

    pub fn read_u8(&self, addr: u16) -> u8 {
        match addr & 0xF000 {
            0x0000 | 0x1000 | 0x2000 | 0x3000 | 0x4000 | 0x5000 | 0x6000 | 0x7000 => {
                if self.bios_enabled && addr < 0x100 {
                    return self.bios[addr as usize];
                }

                self.cartridge.read_rom(addr)
            }

            _ => todo!(),
        }
    }

    pub fn write_u8(&mut self, addr: u16, val: u8) {
        todo!()
    }

    pub fn write_u16(&mut self, addr: u16, val: u16) {
        let lower_val: u8 = (val & 0x00FF) as u8;
        let higher_val: u8 = ((val & 0xFF00) >> 8) as u8;

        self.write_u8(addr, lower_val);
        self.write_u8(addr + 1, higher_val);
    }
}
